from config import HOST_NETMASK, LINK_DELAY, NO_DELAY_FLAG
from config import *
from typing import Dict, Any, List, Union, TextIO


def gen_mn_ns_script_by_template(
        file,
        nodes_ext_intf,
        node_group,
        edge_group,
        ext_intf_list,
        leaves,
        node_ctrl_map,
        hosts_net_services,
):
    """Generate turn on script for Cluster node with network services.

    Args:
        file: File discriptor of future turn on script.
        nodes_ext_intf: Cluster node external network interface name.
        node_group: Group ID to node-list map.
        edge_group: Group ID to edge-list map.
        ext_intf_list: External network interface name to the node group.
        leaves: List of leave-node in network graph.
    """
    file.write('''#!/usr/bin/env python \n''')
    file.write('''import os \n''')
    file.write('''import sys \n''')
    file.write('''import time \n''')
    file.write('''import re \n''')
    file.write(''' \n''')
    file.write('''from functools import partial \n''')
    file.write('''from optparse import OptionParser  # pylint: disable=deprecated-module \n''')
    file.write('''from sys import exit  # pylint: disable=redefined-builtin \n''')
    file.write(''' \n''')
    file.write('''# Fix setuptools' evil madness, and open up (more?) security holes \n''')
    file.write('''if 'PYTHONPATH' in os.environ: \n''')
    file.write('''    sys.path = os.environ[ 'PYTHONPATH' ].split( ':' ) + sys.path \n''')
    file.write(''' \n''')
    file.write('''# pylint: disable=wrong-import-position \n''')
    file.write(''' \n''')
    file.write('''from mininet.clean import cleanup \n''')
    file.write('''import mininet.cli \n''')
    file.write('''from mininet.log import lg, LEVELS, info, debug, warn, error, output \n''')
    file.write('''from mininet.net import Mininet, MininetWithControlNet, VERSION \n''')
    file.write('''from mininet.node import ( Host, CPULimitedHost, Controller, OVSController, \n''')
    file.write('''                           Ryu, NOX, RemoteController, findController, \n''')
    file.write('''                           DefaultController, NullController, \n''')
    file.write('''                           UserSwitch, OVSSwitch, OVSBridge, \n''')
    file.write('''                           IVSSwitch ) \n''')
    file.write('''from mininet.nodelib import LinuxBridge \n''')
    file.write('''from mininet.link import Link, TCLink, TCULink, OVSLink, Intf \n''')
    file.write('''from mininet.topo import ( Topo, SingleSwitchTopo, LinearTopo, \n''')
    file.write('''                           SingleSwitchReversedTopo, MinimalTopo ) \n''')
    file.write('''from mininet.topolib import TreeTopo, TorusTopo \n''')
    file.write('''from mininet.util import customClass, specialClass, splitArgs, buildTopo, quietRun \n''')
    file.write(''' \n''')
    file.write('''# Experimental! cluster edition prototype \n''')
    file.write('''from mininet.examples.cluster import ( MininetCluster, RemoteHost, \n''')
    file.write('''                                       RemoteOVSSwitch, RemoteLink, \n''')
    file.write('''                                       SwitchBinPlacer, RandomPlacer, \n''')
    file.write('''                                       ClusterCleanup ) \n''')
    file.write('''from mininet.examples.clustercli import ClusterCLI \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    sw_ext_intf = {', '.join(map(lambda v: f'\'s{v}\'', ext_intf_list))}
    file.write(f"sw_ext_intf = [{sw_ext_intf}]")
    file.write('''class MyTopology(Topo): \n''')
    file.write('''    "Auto generated topology for this Mininet Node" \n''')
    file.write(''' \n''')
    file.write('''    def __init__(self): \n''')
    file.write('''        super().__init__() \n''')
    file.write(''' \n''')
    file.write('''        "Add hosts and swiches" \n''')
    file.write(
        '\n'.join(
            map(
                lambda s: s.rjust(len(s) + 8, ' '),
                map(
                    lambda node: f"h{node} = self.addHost(name='h{node}')" \
                        if node in leaves else f"s{node} = self.addSwitch(name='s{node}', protocols='OpenFlow13', dpid='{hex(node)[2:].upper().rjust(16, '0')}')",
                    node_group
                )
            )
        )
    )
    file.write(''' \n''')
    file.write('''        "Add links"\n''')
    file.write(
        '\n'.join(
            map(
                lambda s: s.rjust(len(s) + 8, ' '),
                map(
                    lambda
                        edge: f"self.addLink({'h' if edge[0] in leaves else 's'}{edge[0]}, {'h' if edge[1] in leaves else 's'}{edge[1]})",
                    edge_group
                )
            )
        )
    )
    file.write('''# ======================================================== \n''')
    file.write(''' \n''')
    file.write('''def checkIntf( intf ): \n''')
    file.write('''    "Make sure intf exists and is not configured." \n''')
    file.write('''    config = quietRun( 'ifconfig %s 2>/dev/null' % intf, shell=True ) \n''')
    file.write('''    if not config: \n''')
    file.write('''        error( 'Error:', intf, 'does not exist!\\n' ) \n''')
    file.write('''        exit( 1 ) \n''')
    file.write('''    ips = re.findall( r'\d+\.\d+\.\d+\.\d+', config ) \n''')
    file.write('''    if ips: \n''')
    file.write('''        error( 'Error:', intf, 'has an IP address,' \n''')
    file.write('''               'and is probably in use!\\n' ) \n''')
    file.write('''        exit( 1 ) \n''')
    file.write(''' \n''')
    file.write('''PLACEMENT = { 'block': SwitchBinPlacer, 'random': RandomPlacer } \n''')
    file.write(''' \n''')
    file.write('''# built in topologies, created only when run \n''')
    file.write('''TOPODEF = 'minimal' \n''')
    file.write('''TOPOS = { 'minimal': MinimalTopo, \n''')
    file.write('''          'linear': LinearTopo, \n''')
    file.write('''          'reversed': SingleSwitchReversedTopo, \n''')
    file.write('''          'single': SingleSwitchTopo, \n''')
    file.write('''          'tree': TreeTopo, \n''')
    file.write('''          'torus': TorusTopo } \n''')
    file.write(''' \n''')
    file.write('''SWITCHDEF = 'default' \n''')
    file.write('''SWITCHES = { 'user': UserSwitch, \n''')
    file.write('''             'ovs': OVSSwitch, \n''')
    file.write('''             'ovsbr' : OVSBridge, \n''')
    file.write('''             # Keep ovsk for compatibility with 2.0 \n''')
    file.write('''             'ovsk': OVSSwitch, \n''')
    file.write('''             'ivs': IVSSwitch, \n''')
    file.write('''             'lxbr': LinuxBridge, \n''')
    file.write('''             'default': OVSSwitch } \n''')
    file.write(''' \n''')
    file.write('''HOSTDEF = 'proc' \n''')
    file.write('''HOSTS = { 'proc': Host, \n''')
    file.write('''          'rt': specialClass( CPULimitedHost, defaults=dict( sched='rt' ) ), \n''')
    file.write('''          'cfs': specialClass( CPULimitedHost, defaults=dict( sched='cfs' ) ) } \n''')
    file.write(''' \n''')
    file.write('''CONTROLLERDEF = 'default' \n''')
    file.write('''CONTROLLERS = { 'ref': Controller, \n''')
    file.write('''                'ovsc': OVSController, \n''')
    file.write('''                'nox': NOX, \n''')
    file.write('''                'remote': RemoteController, \n''')
    file.write('''                'ryu': Ryu, \n''')
    file.write('''                'default': DefaultController,  # Note: overridden below \n''')
    file.write('''                'none': NullController } \n''')
    file.write(''' \n''')
    file.write('''LINKDEF = 'default' \n''')
    file.write('''LINKS = { 'default': Link,  # Note: overridden below \n''')
    file.write('''          'tc': TCLink, \n''')
    file.write('''          'tcu': TCULink, \n''')
    file.write('''          'ovs': OVSLink } \n''')
    file.write(''' \n''')
    file.write('''# TESTS dict can contain functions and/or Mininet() method names \n''')
    file.write('''# XXX: it would be nice if we could specify a default test, but \n''')
    file.write('''# this may be tricky \n''')
    file.write('''TESTS = { name: True \n''')
    file.write('''          for name in ( 'pingall', 'pingpair', 'iperf', 'iperfudp' ) } \n''')
    file.write(''' \n''')
    file.write('''CLI = None  # Set below if needed \n''')
    file.write(''' \n''')
    file.write('''# Locally defined tests \n''')
    file.write('''def allTest( net ): \n''')
    file.write('''    "Run ping and iperf tests" \n''')
    file.write('''    net.start() \n''')
    file.write('''    net.ping() \n''')
    file.write('''    net.iperf() \n''')
    file.write(''' \n''')
    file.write('''def nullTest( _net ): \n''')
    file.write('''    "Null 'test' (does nothing)" \n''')
    file.write('''    pass \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''TESTS.update( all=allTest, none=nullTest, build=nullTest ) \n''')
    file.write(''' \n''')
    file.write('''# Map to alternate spellings of Mininet() methods \n''')
    file.write('''ALTSPELLING = { 'pingall': 'pingAll', 'pingpair': 'pingPair', \n''')
    file.write('''                'iperfudp': 'iperfUdp' } \n''')
    file.write(''' \n''')
    file.write('''def runTests( mn, options ): \n''')
    file.write('''    """Run tests \n''')
    file.write('''       mn: Mininet object \n''')
    file.write('''       option: list of test optinos """ \n''')
    file.write('''    # Split option into test name and parameters \n''')
    file.write('''    for option in options: \n''')
    file.write('''        # Multiple tests may be separated by '+' for now \n''')
    file.write('''        for test in option.split( '+' ): \n''')
    file.write('''            test, args, kwargs = splitArgs( test ) \n''')
    file.write('''            test = ALTSPELLING.get( test.lower(), test ) \n''')
    file.write('''            testfn = TESTS.get( test, test ) \n''')
    file.write('''            if callable( testfn ): \n''')
    file.write('''                testfn( mn, *args, **kwargs ) \n''')
    file.write('''            elif hasattr( mn, test ): \n''')
    file.write('''                getattr( mn, test )( *args, **kwargs ) \n''')
    file.write('''            else: \n''')
    file.write('''                raise Exception( 'Test %s is unknown - please specify one of ' \n''')
    file.write('''                                 '%s ' % ( test, TESTS.keys() ) ) \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''def addDictOption( opts, choicesDict, default, name, **kwargs ): \n''')
    file.write('''    """Convenience function to add choices dicts to OptionParser. \n''')
    file.write('''       opts: OptionParser instance \n''')
    file.write('''       choicesDict: dictionary of valid choices, must include default \n''')
    file.write('''       default: default choice key \n''')
    file.write('''       name: long option name \n''')
    file.write('''       kwargs: additional arguments to add_option""" \n''')
    file.write('''    helpStr = ( '|'.join( sorted( choicesDict.keys() ) ) + \n''')
    file.write('''                '[,param=value...]' ) \n''')
    file.write('''    helpList = [ '%s=%s' % ( k, v.__name__ ) \n''')
    file.write('''                 for k, v in choicesDict.items() ] \n''')
    file.write('''    helpStr += ' ' + ( ' '.join( helpList ) ) \n''')
    file.write('''    params = dict( type='string', default=default, help=helpStr ) \n''')
    file.write('''    params.update( **kwargs ) \n''')
    file.write('''    opts.add_option( '--' + name, **params ) \n''')
    file.write(''' \n''')
    file.write('''def version( *_args ): \n''')
    file.write('''    "Print Mininet version and exit" \n''')
    file.write('''    output( "%s\\n" % VERSION ) \n''')
    file.write('''    exit() \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''class MininetRunner( object ): \n''')
    file.write('''    "Build, setup, and run Mininet." \n''')
    file.write(''' \n''')
    file.write('''    def __init__( self ): \n''')
    file.write('''        "Init." \n''')
    file.write('''        self.options = None \n''')
    file.write('''        self.args = None  # May be used someday for more CLI scripts \n''')
    file.write('''        self.validate = None \n''')
    file.write(''' \n''')
    file.write('''        self.parseArgs() \n''')
    file.write('''        self.setup() \n''')
    file.write('''        self.begin() \n''')
    file.write(''' \n''')
    file.write('''    def custom( self, _option, _opt_str, value, _parser ): \n''')
    file.write('''        """Parse custom file and add params. \n''')
    file.write('''           option: option e.g. --custom \n''')
    file.write('''           opt_str: option string e.g. --custom \n''')
    file.write('''           value: the value the follows the option \n''')
    file.write('''           parser: option parser instance""" \n''')
    file.write('''        files = [] \n''')
    file.write('''        if os.path.isfile( value ): \n''')
    file.write('''            # Accept any single file (including those with commas) \n''')
    file.write('''            files.append( value ) \n''')
    file.write('''        else: \n''')
    file.write('''            # Accept a comma-separated list of filenames \n''')
    file.write('''            files += value.split(',') \n''')
    file.write(''' \n''')
    file.write('''        for fileName in files: \n''')
    file.write('''            customs = {} \n''')
    file.write('''            if os.path.isfile( fileName ): \n''')
    file.write('''                # pylint: disable=exec-used \n''')
    file.write('''                with open( fileName ) as f: \n''')
    file.write('''                    exec( compile( f.read(), fileName, 'exec' ), \n''')
    file.write('''                          customs, customs ) \n''')
    file.write('''                for name, val in customs.items(): \n''')
    file.write('''                    self.setCustom( name, val ) \n''')
    file.write('''            else: \n''')
    file.write('''                raise Exception( 'could not find custom file: %s' % fileName ) \n''')
    file.write(''' \n''')
    file.write('''    def setCustom( self, name, value ): \n''')
    file.write('''        "Set custom parameters for MininetRunner." \n''')
    file.write('''        if name in ( 'topos', 'switches', 'hosts', 'controllers', 'links' \n''')
    file.write('''                     'testnames', 'tests' ): \n''')
    file.write('''            # Update dictionaries \n''')
    file.write('''            param = name.upper() \n''')
    file.write('''            globals()[ param ].update( value ) \n''')
    file.write('''        elif name == 'validate': \n''')
    file.write('''            # Add custom validate function \n''')
    file.write('''            self.validate = value \n''')
    file.write('''        else: \n''')
    file.write('''            # Add or modify global variable or class \n''')
    file.write('''            globals()[ name ] = value \n''')
    file.write(''' \n''')
    file.write('''    def setNat( self, _option, opt_str, value, parser ): \n''')
    file.write('''        "Set NAT option(s)" \n''')
    file.write('''        assert self  # satisfy pylint \n''')
    file.write('''        parser.values.nat = True \n''')
    file.write('''        # first arg, first char != '-' \n''')
    file.write('''        if parser.rargs and parser.rargs[ 0 ][ 0 ] != '-': \n''')
    file.write('''            value = parser.rargs.pop( 0 ) \n''')
    file.write('''            _, args, kwargs = splitArgs( opt_str + ',' + value ) \n''')
    file.write('''            parser.values.nat_args = args \n''')
    file.write('''            parser.values.nat_kwargs = kwargs \n''')
    file.write('''        else: \n''')
    file.write('''            parser.values.nat_args = [] \n''')
    file.write('''            parser.values.nat_kwargs = {} \n''')
    file.write(''' \n''')
    file.write('''    def parseArgs( self ): \n''')
    file.write('''        """Parse command-line args and return options object. \n''')
    file.write('''           returns: opts parse options dict""" \n''')
    file.write(''' \n''')
    file.write('''        desc = ( "The %prog utility creates Mininet network from the\\n" \n''')
    file.write('''                 "command line. It can create parametrized topologies,\\n" \n''')
    file.write('''                 "invoke the Mininet CLI, and run tests." ) \n''')
    file.write(''' \n''')
    file.write('''        usage = ( '%prog [options]\\n' \n''')
    file.write('''                  '(type %prog -h for details)' ) \n''')
    file.write(''' \n''')
    file.write('''        opts = OptionParser( description=desc, usage=usage ) \n''')
    file.write('''        addDictOption( opts, SWITCHES, SWITCHDEF, 'switch' ) \n''')
    file.write('''        addDictOption( opts, HOSTS, HOSTDEF, 'host' ) \n''')
    file.write('''        addDictOption( opts, CONTROLLERS, [], 'controller', action='append' ) \n''')
    file.write('''        addDictOption( opts, LINKS, LINKDEF, 'link' ) \n''')
    file.write('''        addDictOption( opts, TOPOS, TOPODEF, 'topo' ) \n''')
    file.write(''' \n''')
    file.write('''        opts.add_option( '--clean', '-c', action='store_true', \n''')
    file.write('''                         default=False, help='clean and exit' ) \n''')
    file.write('''        opts.add_option( '--custom', action='callback', \n''')
    file.write('''                         callback=self.custom, \n''')
    file.write('''                         type='string', \n''')
    file.write('''                         help='read custom classes or params from .py file(s)' \n''')
    file.write('''                         ) \n''')
    file.write('''        opts.add_option( '--test', default=[], action='append', \n''')
    file.write('''                         dest='test', help='|'.join( TESTS.keys() ) ) \n''')
    file.write('''        opts.add_option( '--xterms', '-x', action='store_true', \n''')
    file.write('''                         default=False, help='spawn xterms for each node' ) \n''')
    file.write('''        opts.add_option( '--ipbase', '-i', type='string', default='10.0.0.0/8', \n''')
    file.write('''                         help='base IP address for hosts' ) \n''')
    file.write('''        opts.add_option( '--mac', action='store_true', \n''')
    file.write('''                         default=False, help='automatically set host MACs' ) \n''')
    file.write('''        opts.add_option( '--arp', action='store_true', \n''')
    file.write('''                         default=False, help='set all-pairs ARP entries' ) \n''')
    file.write('''        opts.add_option( '--verbosity', '-v', type='choice', \n''')
    file.write('''                         choices=list( LEVELS.keys() ), default = 'info', \n''')
    file.write('''                         help = '|'.join( LEVELS.keys() )  ) \n''')
    file.write('''        opts.add_option( '--innamespace', action='store_true', \n''')
    file.write('''                         default=False, help='sw and ctrl in namespace?' ) \n''')
    file.write('''        opts.add_option( '--listenport', type='int', default=6654, \n''')
    file.write('''                         help='base port for passive switch listening' ) \n''')
    file.write('''        opts.add_option( '--nolistenport', action='store_true', \n''')
    file.write('''                         default=False, help="don't use passive listening " + \n''')
    file.write('''                         "port") \n''')
    file.write('''        opts.add_option( '--pre', type='string', default=None, \n''')
    file.write('''                         help='CLI script to run before tests' ) \n''')
    file.write('''        opts.add_option( '--post', type='string', default=None, \n''')
    file.write('''                         help='CLI script to run after tests' ) \n''')
    file.write('''        opts.add_option( '--pin', action='store_true', \n''')
    file.write('''                         default=False, help="pin hosts to CPU cores " \n''')
    file.write('''                         "(requires --host cfs or --host rt)" ) \n''')
    file.write('''        opts.add_option( '--nat', action='callback', callback=self.setNat, \n''')
    file.write('''                         help="[option=val...] adds a NAT to the topology that" \n''')
    file.write('''                         " connects Mininet hosts to the physical network." \n''')
    file.write('''                         " Warning: This may route any traffic on the machine" \n''')
    file.write('''                         " that uses Mininet's" \n''')
    file.write('''                         " IP subnet into the Mininet network." \n''')
    file.write('''                         " If you need to change" \n''')
    file.write('''                         " Mininet's IP subnet, see the --ipbase option." ) \n''')
    file.write('''        opts.add_option( '--version', action='callback', callback=version, \n''')
    file.write('''                         help='prints the version and exits' ) \n''')
    file.write('''        opts.add_option( '--wait', '-w', action='store_true', \n''')
    file.write('''                         default=False, help='wait for switches to connect' ) \n''')
    file.write('''        opts.add_option( '--twait', '-t', action='store', type='int', \n''')
    file.write('''                         dest='wait', \n''')
    file.write('''                         help='timed wait (s) for switches to connect' ) \n''')
    file.write('''        opts.add_option( '--cluster', type='string', default=None, \n''')
    file.write('''                         metavar='server1,server2...', \n''')
    file.write('''                         help=( 'run on multiple servers (experimental!)' ) ) \n''')
    file.write('''        opts.add_option( '--placement', type='choice', \n''')
    file.write('''                         choices=list( PLACEMENT.keys() ), default='block', \n''')
    file.write('''                         metavar='block|random', \n''')
    file.write('''                         help=( 'node placement for --cluster ' \n''')
    file.write('''                                '(experimental!) ' ) ) \n''')
    file.write(''' \n''')
    file.write('''        self.options, self.args = opts.parse_args() \n''')
    file.write(''' \n''')
    file.write('''        # We don't accept extra arguments after the options \n''')
    file.write('''        if self.args: \n''')
    file.write('''            opts.print_help() \n''')
    file.write('''            exit() \n''')
    file.write(''' \n''')
    file.write('''    def setup( self ): \n''')
    file.write('''        "Setup and validate environment." \n''')
    file.write(''' \n''')
    file.write('''        # set logging verbosity \n''')
    file.write('''        if LEVELS[self.options.verbosity] > LEVELS['output']: \n''')
    file.write('''            warn( '*** WARNING: selected verbosity level (%s) will hide CLI ' \n''')
    file.write('''                    'output!\\n' \n''')
    file.write('''                    'Please restart Mininet with -v [debug, info, output].\\n' \n''')
    file.write('''                    % self.options.verbosity ) \n''')
    file.write('''        lg.setLogLevel( self.options.verbosity ) \n''')
    file.write(''' \n''')
    file.write('''    # Maybe we'll reorganize this someday... \n''')
    file.write('''    # pylint: disable=too-many-branches,too-many-statements,global-statement \n''')
    file.write(''' \n''')
    file.write('''    def begin( self ): \n''')
    file.write('''        "Create and run mininet." \n''')
    file.write(''' \n''')
    file.write('''        global CLI \n''')
    file.write(''' \n''')
    file.write('''        opts = self.options \n''')
    file.write(''' \n''')
    file.write('''        if opts.cluster: \n''')
    file.write('''            servers = opts.cluster.split( ',' ) \n''')
    file.write('''            for server in servers: \n''')
    file.write('''                ClusterCleanup.add( server ) \n''')
    file.write(''' \n''')
    file.write('''        if opts.clean: \n''')
    file.write('''            cleanup() \n''')
    file.write('''            exit() \n''')
    file.write(''' \n''')
    file.write('''        start = time.time() \n''')
    file.write(''' \n''')
    file.write('''        topo = MyTopology() \n''')
    file.write('''        switch = customClass( SWITCHES, opts.switch ) \n''')
    file.write('''        host = customClass( HOSTS, opts.host ) \n''')
    file.write(
        f'''        controller = lambda name: RemoteController(name=name, ip='{node_ctrl_map[0]}', port={node_ctrl_map[1]})\n''')
    file.write('''        link = customClass( LINKS, opts.link )\n''')
    file.write('''        listenPort = None\n''')
    file.write('''        if self.validate:\n''')
    file.write('''            self.validate( opts )\n''')
    file.write(''' \n''')
    file.write('''        if not opts.nolistenport:\n''')
    file.write('''            listenPort = opts.listenport\n''')
    file.write('''\n''')
    file.write('''        Net = MininetWithControlNet if opts.innamespace else Mininet\n''')
    file.write('''\n''')
    file.write('''        # Wait for controllers to connect unless we're running null test\n''')
    file.write('''        if ( opts.test and opts.test != [ 'none' ] and\n''')
    file.write('''             isinstance( opts.wait, bool ) ):\n''')
    file.write('''            opts.wait = True\n''')
    file.write('''\n''')
    file.write(f'''        intfName = '{nodes_ext_intf}'\n''')
    file.write('''        info('*** Checking', intfName, '\\n')\n''')
    file.write('''        checkIntf(intfName)\n''')
    file.write(''' \n''')
    file.write('''        mn = Net( topo=topo, \n''')
    file.write('''                  switch=switch, host=host, controller=controller, link=link, \n''')
    file.write('''                  ipBase=opts.ipbase, inNamespace=opts.innamespace, \n''')
    file.write('''                  xterms=opts.xterms, autoSetMacs=opts.mac, \n''')
    file.write('''                  autoStaticArp=opts.arp, autoPinCpus=opts.pin, \n''')
    file.write('''                  waitConnected=opts.wait, \n''')
    file.write('''                  listenPort=listenPort ) \n''')
    file.write('''         \n''')
    file.write('''        for sw in mn.switches: \n''')
    file.write('''            if sw.name in sw_ext_intf: \n''')
    file.write('''                info('*** Adding hardware interface', intfName, 'to switch', \n''')
    file.write('''                     sw.name, '\\n') \n''')
    file.write('''                _intf = Intf(intfName, node=sw) \n''')
    file.write(''' \n''')
    file.write('''        info('*** Note: you may need to reconfigure the interfaces for ' \n''')
    file.write('''             'the Mininet hosts:\\n', mn.hosts, '\\n') \n''')
    file.write(''' \n''')
    file.write('''        if opts.ensure_value( 'nat', False ): \n''')
    file.write('''            with open( '/etc/resolv.conf' ) as f: \n''')
    file.write('''                if 'nameserver 127.' in f.read(): \n''')
    file.write('''                    warn( '*** Warning: loopback address in /etc/resolv.conf ' \n''')
    file.write('''                          'may break host DNS over NAT\\n') \n''')
    file.write('''            mn.addNAT( *opts.nat_args, **opts.nat_kwargs ).configDefault() \n''')
    file.write(''' \n''')
    file.write('''        # --custom files can set CLI or change mininet.cli.CLI \n''')
    file.write('''        CLI = mininet.cli.CLI if CLI is None else CLI \n''')
    file.write(''' \n''')
    file.write('''        if opts.pre: \n''')
    file.write('''            CLI( mn, script=opts.pre ) \n''')
    file.write(''' \n''')
    file.write('''        mn.start() \n''')
    file.write(''' \n''')
    file.write('''        if opts.test: \n''')
    file.write('''            runTests( mn, opts.test ) \n''')
    file.write('''        else: \n''')
    file.write('''            CLI( mn ) \n''')
    file.write(''' \n''')
    file.write('''        if opts.post: \n''')
    file.write('''            CLI( mn, script=opts.post ) \n''')
    file.write(''' \n''')
    file.write('''        mn.stop() \n''')
    file.write(''' \n''')
    file.write('''        elapsed = float( time.time() - start ) \n''')
    file.write('''        info( 'completed in %0.3f seconds\\n' % elapsed ) \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''if __name__ == "__main__": \n''')
    file.write('''    try: \n''')
    file.write('''        MininetRunner() \n''')
    file.write('''    except KeyboardInterrupt: \n''')
    file.write('''        info( "\\n\\nKeyboard Interrupt. Shutting down and cleaning up...\\n\\n") \n''')
    file.write('''        cleanup() \n''')
    file.write('''    except Exception:  # pylint: disable=broad-except \n''')
    file.write('''        # Print exception \n''')
    file.write('''        type_, val_, trace_ = sys.exc_info() \n''')
    file.write('''        errorMsg = ( "-"*80 + "\\n" + \n''')
    file.write('''                     "Caught exception. Cleaning up...\\n\\n" + \n''')
    file.write('''                     "%s: %s\\n" % ( type_.__name__, val_ ) + \n''')
    file.write('''                     "-"*80 + "\\n" ) \n''')
    file.write('''        error( errorMsg ) \n''')
    file.write('''        # Print stack trace to debug log \n''')
    file.write('''        import traceback \n''')
    file.write('''        stackTrace = traceback.format_exc() \n''')
    file.write('''        debug( stackTrace + "\\n" ) \n''')
    file.write('''        cleanup()\n''')


def gen_mn_ns_script_by_template_with_custom_host_ip(
        file: TextIO,
        node: Dict[str, str],
        group: Dict[str, List[Union[str, int]]],
        spec_group: Dict[str, List[Union[str, int]]],
        leaves: List[int],
        hosts_net_services: Any,
        hosts: Dict[str, Dict[str, str]],
) -> None:
    """
    Generate turn on script for Cluster node with network services and with custom host IP addresses

    :param file: File descriptor of future turn on script.
    :type file: io.TextIOWrapper
    :param node:
    :type node:
    :param group: Cluster node external network interface name.
    :type group: Dict[str, str]
    :param spec_group: Group ID to edge-list map.
    :type spec_group: Dict[str, List[Union[str, int]]]
    :param leaves: List of leave-node in network graph.
    :type leaves: List[int]
    :param hosts_net_services:
    :type hosts_net_services: Any
    :param hosts:
    :type hosts: Dict[str, str]
    """

    file.write('''#!/usr/bin/env python \n''')
    file.write('''import os \n''')
    file.write('''import sys \n''')
    file.write('''import time \n''')
    file.write('''import re \n''')
    file.write(''' \n''')
    file.write('''from functools import partial \n''')
    file.write('''from optparse import OptionParser  # pylint: disable=deprecated-module \n''')
    file.write('''from sys import exit  # pylint: disable=redefined-builtin \n''')
    file.write(''' \n''')
    file.write('''# Fix setuptools' evil madness, and open up (more?) security holes \n''')
    file.write('''if 'PYTHONPATH' in os.environ: \n''')
    file.write('''    sys.path = os.environ[ 'PYTHONPATH' ].split( ':' ) + sys.path \n''')
    file.write(''' \n''')
    file.write('''# pylint: disable=wrong-import-position \n''')
    file.write(''' \n''')
    file.write('''from mininet.clean import cleanup \n''')
    file.write('''import mininet.cli \n''')
    file.write('''from mininet.log import lg, LEVELS, info, debug, warn, error, output \n''')
    file.write('''from mininet.net import Mininet, MininetWithControlNet, VERSION \n''')
    file.write('''from mininet.node import ( Host, CPULimitedHost, Controller, OVSController, \n''')
    file.write('''                           Ryu, NOX, RemoteController, findController, \n''')
    file.write('''                           DefaultController, NullController, \n''')
    file.write('''                           UserSwitch, OVSSwitch, OVSBridge, \n''')
    file.write('''                           IVSSwitch ) \n''')
    file.write('''from mininet.nodelib import LinuxBridge \n''')
    file.write('''from mininet.link import Link, TCLink, TCULink, OVSLink, Intf \n''')
    file.write('''from mininet.topo import ( Topo, SingleSwitchTopo, LinearTopo, \n''')
    file.write('''                           SingleSwitchReversedTopo, MinimalTopo ) \n''')
    file.write('''from mininet.topolib import TreeTopo, TorusTopo \n''')
    file.write('''from mininet.util import customClass, specialClass, splitArgs, buildTopo, quietRun \n''')
    file.write(''' \n''')
    file.write('''# Experimental! cluster edition prototype \n''')
    file.write('''from mininet.examples.cluster import ( MininetCluster, RemoteHost, \n''')
    file.write('''                                       RemoteOVSSwitch, RemoteLink, \n''')
    file.write('''                                       SwitchBinPlacer, RandomPlacer, \n''')
    file.write('''                                       ClusterCleanup ) \n''')
    file.write('''from mininet.examples.clustercli import ClusterCLI \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''# ======================================================== \n''')
    file.write(''' \n''')
    sw_ext_intf = ', '.join(map(lambda v: f'\'s{v}\'', spec_group['vertexes']))
    file.write(f"sw_ext_intf = [{sw_ext_intf}]\n")
    file.write('sw_ext_intf_edges = [' + ', '.join(map(lambda v: str((f"s{v[0]}", f"s{v[1]}")), spec_group['edges'])) + ']')

    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''class MyTopology(Topo): \n''')
    file.write('''    "Auto generated topology for this Mininet Node" \n''')
    file.write(''' \n''')
    file.write('''    def __init__(self): \n''')
    file.write('''        super().__init__() \n''')
    file.write(''' \n''')
    file.write('''        "Add hosts and swiches" \n''')
    file.write(
        '\n'.join(
            map(
                lambda s: s.rjust(len(s) + 8, ' '),
                map(
                    lambda v: f"h{v} = self.addHost(name='h{v}', ip='{hosts['h' + str(v)]['IP']}\{HOST_NETMASK}')" \
                        if v in leaves else f"s{v} = self.addSwitch(name='s{v}', protocols='OpenFlow13', dpid='{hex(v + 1)[2:].upper().rjust(16, '0')}')",
                    group["vertexes"]
                )
            )
        )
    )
    file.write('''\n''')
    file.write('''        "Add links"\n''')
    file.write(
        '\n'.join(
            map(
                lambda s: s.rjust(len(s) + 8, ' '),
                map(
                    lambda edge: f"self.addLink({'h' if edge[0] in leaves else 's'}{edge[0]}, {'h' if edge[1] in leaves else 's'}{edge[1]}" +\
                              (f", delay='{LINK_DELAY}ms')" if not NO_DELAY_FLAG else ")"),
                    group["edges"]
                )
            )
        )
    )
    file.write(''' \n''')
    file.write('''# ======================================================== \n''')
    file.write(''' \n''')
    file.write('''def checkIntf( intf ): \n''')
    file.write('''    "Make sure intf exists and is not configured." \n''')
    file.write('''    config = quietRun( 'ifconfig %s 2>/dev/null' % intf, shell=True ) \n''')
    file.write('''    if not config: \n''')
    file.write('''        error( 'Error:', intf, 'does not exist!\\n' ) \n''')
    file.write('''        exit( 1 ) \n''')
    file.write('''    ips = re.findall( r'\d+\.\d+\.\d+\.\d+', config ) \n''')
    file.write('''    if ips: \n''')
    file.write('''        error( 'Error:', intf, 'has an IP address,' \n''')
    file.write('''               'and is probably in use!\\n' ) \n''')
    file.write('''        exit( 1 ) \n''')
    file.write(''' \n''')
    file.write('''PLACEMENT = { 'block': SwitchBinPlacer, 'random': RandomPlacer } \n''')
    file.write(''' \n''')
    file.write('''# built in topologies, created only when run \n''')
    file.write('''TOPODEF = 'minimal' \n''')
    file.write('''TOPOS = { 'minimal': MinimalTopo, \n''')
    file.write('''          'linear': LinearTopo, \n''')
    file.write('''          'reversed': SingleSwitchReversedTopo, \n''')
    file.write('''          'single': SingleSwitchTopo, \n''')
    file.write('''          'tree': TreeTopo, \n''')
    file.write('''          'torus': TorusTopo } \n''')
    file.write(''' \n''')
    file.write('''SWITCHDEF = 'default' \n''')
    file.write('''SWITCHES = { 'user': UserSwitch, \n''')
    file.write('''             'ovs': OVSSwitch, \n''')
    file.write('''             'ovsbr' : OVSBridge, \n''')
    file.write('''             # Keep ovsk for compatibility with 2.0 \n''')
    file.write('''             'ovsk': OVSSwitch, \n''')
    file.write('''             'ivs': IVSSwitch, \n''')
    file.write('''             'lxbr': LinuxBridge, \n''')
    file.write('''             'default': OVSSwitch } \n''')
    file.write(''' \n''')
    file.write('''HOSTDEF = 'proc' \n''')
    file.write('''HOSTS = { 'proc': Host, \n''')
    file.write('''          'rt': specialClass( CPULimitedHost, defaults=dict( sched='rt' ) ), \n''')
    file.write('''          'cfs': specialClass( CPULimitedHost, defaults=dict( sched='cfs' ) ) } \n''')
    file.write(''' \n''')
    file.write('''CONTROLLERDEF = 'default' \n''')
    file.write('''CONTROLLERS = { 'ref': Controller, \n''')
    file.write('''                'ovsc': OVSController, \n''')
    file.write('''                'nox': NOX, \n''')
    file.write('''                'remote': RemoteController, \n''')
    file.write('''                'ryu': Ryu, \n''')
    file.write('''                'default': DefaultController,  # Note: overridden below \n''')
    file.write('''                'none': NullController } \n''')
    file.write(''' \n''')
    file.write('''LINKDEF = 'default' \n''')
    file.write('''LINKS = { 'default': Link,  # Note: overridden below \n''')
    file.write('''          'tc': TCLink, \n''')
    file.write('''          'tcu': TCULink, \n''')
    file.write('''          'ovs': OVSLink } \n''')
    file.write(''' \n''')
    file.write('''# TESTS dict can contain functions and/or Mininet() method names \n''')
    file.write('''# XXX: it would be nice if we could specify a default test, but \n''')
    file.write('''# this may be tricky \n''')
    file.write('''TESTS = { name: True \n''')
    file.write('''          for name in ( 'pingall', 'pingpair', 'iperf', 'iperfudp' ) } \n''')
    file.write(''' \n''')
    file.write('''CLI = None  # Set below if needed \n''')
    file.write(''' \n''')
    file.write('''# Locally defined tests \n''')
    file.write('''def allTest( net ): \n''')
    file.write('''    "Run ping and iperf tests" \n''')
    file.write('''    net.start() \n''')
    file.write('''    net.ping() \n''')
    file.write('''    net.iperf() \n''')
    file.write(''' \n''')
    file.write('''def nullTest( _net ): \n''')
    file.write('''    "Null 'test' (does nothing)" \n''')
    file.write('''    pass \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''TESTS.update( all=allTest, none=nullTest, build=nullTest ) \n''')
    file.write(''' \n''')
    file.write('''# Map to alternate spellings of Mininet() methods \n''')
    file.write('''ALTSPELLING = { 'pingall': 'pingAll', 'pingpair': 'pingPair', \n''')
    file.write('''                'iperfudp': 'iperfUdp' } \n''')
    file.write(''' \n''')
    file.write('''def runTests( mn, options ): \n''')
    file.write('''    """Run tests \n''')
    file.write('''       mn: Mininet object \n''')
    file.write('''       option: list of test optinos """ \n''')
    file.write('''    # Split option into test name and parameters \n''')
    file.write('''    for option in options: \n''')
    file.write('''        # Multiple tests may be separated by '+' for now \n''')
    file.write('''        for test in option.split( '+' ): \n''')
    file.write('''            test, args, kwargs = splitArgs( test ) \n''')
    file.write('''            test = ALTSPELLING.get( test.lower(), test ) \n''')
    file.write('''            testfn = TESTS.get( test, test ) \n''')
    file.write('''            if callable( testfn ): \n''')
    file.write('''                testfn( mn, *args, **kwargs ) \n''')
    file.write('''            elif hasattr( mn, test ): \n''')
    file.write('''                getattr( mn, test )( *args, **kwargs ) \n''')
    file.write('''            else: \n''')
    file.write('''                raise Exception( 'Test %s is unknown - please specify one of ' \n''')
    file.write('''                                 '%s ' % ( test, TESTS.keys() ) ) \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''def addDictOption( opts, choicesDict, default, name, **kwargs ): \n''')
    file.write('''    """Convenience function to add choices dicts to OptionParser. \n''')
    file.write('''       opts: OptionParser instance \n''')
    file.write('''       choicesDict: dictionary of valid choices, must include default \n''')
    file.write('''       default: default choice key \n''')
    file.write('''       name: long option name \n''')
    file.write('''       kwargs: additional arguments to add_option""" \n''')
    file.write('''    helpStr = ( '|'.join( sorted( choicesDict.keys() ) ) + \n''')
    file.write('''                '[,param=value...]' ) \n''')
    file.write('''    helpList = [ '%s=%s' % ( k, v.__name__ ) \n''')
    file.write('''                 for k, v in choicesDict.items() ] \n''')
    file.write('''    helpStr += ' ' + ( ' '.join( helpList ) ) \n''')
    file.write('''    params = dict( type='string', default=default, help=helpStr ) \n''')
    file.write('''    params.update( **kwargs ) \n''')
    file.write('''    opts.add_option( '--' + name, **params ) \n''')
    file.write(''' \n''')
    file.write('''def version( *_args ): \n''')
    file.write('''    "Print Mininet version and exit" \n''')
    file.write('''    output( "%s\\n" % VERSION ) \n''')
    file.write('''    exit() \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''class MininetRunner( object ): \n''')
    file.write('''    "Build, setup, and run Mininet." \n''')
    file.write(''' \n''')
    file.write('''    def __init__( self ): \n''')
    file.write('''        "Init." \n''')
    file.write('''        self.options = None \n''')
    file.write('''        self.args = None  # May be used someday for more CLI scripts \n''')
    file.write('''        self.validate = None \n''')
    file.write(''' \n''')
    file.write('''        self.parseArgs() \n''')
    file.write('''        self.setup() \n''')
    file.write('''        self.begin() \n''')
    file.write(''' \n''')
    file.write('''    def custom( self, _option, _opt_str, value, _parser ): \n''')
    file.write('''        """Parse custom file and add params. \n''')
    file.write('''           option: option e.g. --custom \n''')
    file.write('''           opt_str: option string e.g. --custom \n''')
    file.write('''           value: the value the follows the option \n''')
    file.write('''           parser: option parser instance""" \n''')
    file.write('''        files = [] \n''')
    file.write('''        if os.path.isfile( value ): \n''')
    file.write('''            # Accept any single file (including those with commas) \n''')
    file.write('''            files.append( value ) \n''')
    file.write('''        else: \n''')
    file.write('''            # Accept a comma-separated list of filenames \n''')
    file.write('''            files += value.split(',') \n''')
    file.write(''' \n''')
    file.write('''        for fileName in files: \n''')
    file.write('''            customs = {} \n''')
    file.write('''            if os.path.isfile( fileName ): \n''')
    file.write('''                # pylint: disable=exec-used \n''')
    file.write('''                with open( fileName ) as f: \n''')
    file.write('''                    exec( compile( f.read(), fileName, 'exec' ), \n''')
    file.write('''                          customs, customs ) \n''')
    file.write('''                for name, val in customs.items(): \n''')
    file.write('''                    self.setCustom( name, val ) \n''')
    file.write('''            else: \n''')
    file.write('''                raise Exception( 'could not find custom file: %s' % fileName ) \n''')
    file.write(''' \n''')
    file.write('''    def setCustom( self, name, value ): \n''')
    file.write('''        "Set custom parameters for MininetRunner." \n''')
    file.write('''        if name in ( 'topos', 'switches', 'hosts', 'controllers', 'links' \n''')
    file.write('''                     'testnames', 'tests' ): \n''')
    file.write('''            # Update dictionaries \n''')
    file.write('''            param = name.upper() \n''')
    file.write('''            globals()[ param ].update( value ) \n''')
    file.write('''        elif name == 'validate': \n''')
    file.write('''            # Add custom validate function \n''')
    file.write('''            self.validate = value \n''')
    file.write('''        else: \n''')
    file.write('''            # Add or modify global variable or class \n''')
    file.write('''            globals()[ name ] = value \n''')
    file.write(''' \n''')
    file.write('''    def setNat( self, _option, opt_str, value, parser ): \n''')
    file.write('''        "Set NAT option(s)" \n''')
    file.write('''        assert self  # satisfy pylint \n''')
    file.write('''        parser.values.nat = True \n''')
    file.write('''        # first arg, first char != '-' \n''')
    file.write('''        if parser.rargs and parser.rargs[ 0 ][ 0 ] != '-': \n''')
    file.write('''            value = parser.rargs.pop( 0 ) \n''')
    file.write('''            _, args, kwargs = splitArgs( opt_str + ',' + value ) \n''')
    file.write('''            parser.values.nat_args = args \n''')
    file.write('''            parser.values.nat_kwargs = kwargs \n''')
    file.write('''        else: \n''')
    file.write('''            parser.values.nat_args = [] \n''')
    file.write('''            parser.values.nat_kwargs = {} \n''')
    file.write(''' \n''')
    file.write('''    def parseArgs( self ): \n''')
    file.write('''        """Parse command-line args and return options object. \n''')
    file.write('''           returns: opts parse options dict""" \n''')
    file.write(''' \n''')
    file.write('''        desc = ( "The %prog utility creates Mininet network from the\\n" \n''')
    file.write('''                 "command line. It can create parametrized topologies,\\n" \n''')
    file.write('''                 "invoke the Mininet CLI, and run tests." ) \n''')
    file.write(''' \n''')
    file.write('''        usage = ( '%prog [options]\\n' \n''')
    file.write('''                  '(type %prog -h for details)' ) \n''')
    file.write(''' \n''')
    file.write('''        opts = OptionParser( description=desc, usage=usage ) \n''')
    file.write('''        addDictOption( opts, SWITCHES, SWITCHDEF, 'switch' ) \n''')
    file.write('''        addDictOption( opts, HOSTS, HOSTDEF, 'host' ) \n''')
    file.write('''        addDictOption( opts, CONTROLLERS, [], 'controller', action='append' ) \n''')
    file.write('''        addDictOption( opts, LINKS, LINKDEF, 'link' ) \n''')
    file.write('''        addDictOption( opts, TOPOS, TOPODEF, 'topo' ) \n''')
    file.write(''' \n''')
    file.write('''        opts.add_option( '--clean', '-c', action='store_true', \n''')
    file.write('''                         default=False, help='clean and exit' ) \n''')
    file.write('''        opts.add_option( '--custom', action='callback', \n''')
    file.write('''                         callback=self.custom, \n''')
    file.write('''                         type='string', \n''')
    file.write('''                         help='read custom classes or params from .py file(s)' \n''')
    file.write('''                         ) \n''')
    file.write('''        opts.add_option( '--test', default=[], action='append', \n''')
    file.write('''                         dest='test', help='|'.join( TESTS.keys() ) ) \n''')
    file.write('''        opts.add_option( '--xterms', '-x', action='store_true', \n''')
    file.write('''                         default=False, help='spawn xterms for each node' ) \n''')
    file.write('''        opts.add_option( '--ipbase', '-i', type='string', default='10.0.0.0/8', \n''')
    file.write('''                         help='base IP address for hosts' ) \n''')
    file.write('''        opts.add_option( '--mac', action='store_true', \n''')
    file.write('''                         default=False, help='automatically set host MACs' ) \n''')
    file.write('''        opts.add_option( '--arp', action='store_true', \n''')
    file.write('''                         default=False, help='set all-pairs ARP entries' ) \n''')
    file.write('''        opts.add_option( '--verbosity', '-v', type='choice', \n''')
    file.write('''                         choices=list( LEVELS.keys() ), default = 'info', \n''')
    file.write('''                         help = '|'.join( LEVELS.keys() )  ) \n''')
    file.write('''        opts.add_option( '--innamespace', action='store_true', \n''')
    file.write('''                         default=False, help='sw and ctrl in namespace?' ) \n''')
    file.write('''        opts.add_option( '--listenport', type='int', default=6654, \n''')
    file.write('''                         help='base port for passive switch listening' ) \n''')
    file.write('''        opts.add_option( '--nolistenport', action='store_true', \n''')
    file.write('''                         default=False, help="don't use passive listening " + \n''')
    file.write('''                         "port") \n''')
    file.write('''        opts.add_option( '--pre', type='string', default=None, \n''')
    file.write('''                         help='CLI script to run before tests' ) \n''')
    file.write('''        opts.add_option( '--post', type='string', default=None, \n''')
    file.write('''                         help='CLI script to run after tests' ) \n''')
    file.write('''        opts.add_option( '--pin', action='store_true', \n''')
    file.write('''                         default=False, help="pin hosts to CPU cores " \n''')
    file.write('''                         "(requires --host cfs or --host rt)" ) \n''')
    file.write('''        opts.add_option( '--nat', action='callback', callback=self.setNat, \n''')
    file.write('''                         help="[option=val...] adds a NAT to the topology that" \n''')
    file.write('''                         " connects Mininet hosts to the physical network." \n''')
    file.write('''                         " Warning: This may route any traffic on the machine" \n''')
    file.write('''                         " that uses Mininet's" \n''')
    file.write('''                         " IP subnet into the Mininet network." \n''')
    file.write('''                         " If you need to change" \n''')
    file.write('''                         " Mininet's IP subnet, see the --ipbase option." ) \n''')
    file.write('''        opts.add_option( '--version', action='callback', callback=version, \n''')
    file.write('''                         help='prints the version and exits' ) \n''')
    file.write('''        opts.add_option( '--wait', '-w', action='store_true', \n''')
    file.write('''                         default=False, help='wait for switches to connect' ) \n''')
    file.write('''        opts.add_option( '--twait', '-t', action='store', type='int', \n''')
    file.write('''                         dest='wait', \n''')
    file.write('''                         help='timed wait (s) for switches to connect' ) \n''')
    file.write('''        opts.add_option( '--cluster', type='string', default=None, \n''')
    file.write('''                         metavar='server1,server2...', \n''')
    file.write('''                         help=( 'run on multiple servers (experimental!)' ) ) \n''')
    file.write('''        opts.add_option( '--placement', type='choice', \n''')
    file.write('''                         choices=list( PLACEMENT.keys() ), default='block', \n''')
    file.write('''                         metavar='block|random', \n''')
    file.write('''                         help=( 'node placement for --cluster ' \n''')
    file.write('''                                '(experimental!) ' ) ) \n''')
    file.write(''' \n''')
    file.write('''        self.options, self.args = opts.parse_args() \n''')
    file.write(''' \n''')
    file.write('''        # We don't accept extra arguments after the options \n''')
    file.write('''        if self.args: \n''')
    file.write('''            opts.print_help() \n''')
    file.write('''            exit() \n''')
    file.write(''' \n''')
    file.write('''    def setup( self ): \n''')
    file.write('''        "Setup and validate environment." \n''')
    file.write(''' \n''')
    file.write('''        # set logging verbosity \n''')
    file.write('''        if LEVELS[self.options.verbosity] > LEVELS['output']: \n''')
    file.write('''            warn( '*** WARNING: selected verbosity level (%s) will hide CLI ' \n''')
    file.write('''                    'output!\\n' \n''')
    file.write('''                    'Please restart Mininet with -v [debug, info, output].\\n' \n''')
    file.write('''                    % self.options.verbosity ) \n''')
    file.write('''        lg.setLogLevel( self.options.verbosity ) \n''')
    file.write(''' \n''')
    file.write('''    # Maybe we'll reorganize this someday... \n''')
    file.write('''    # pylint: disable=too-many-branches,too-many-statements,global-statement \n''')
    file.write(''' \n''')
    file.write('''    def begin( self ): \n''')
    file.write('''        "Create and run mininet." \n''')
    file.write(''' \n''')
    file.write('''        global CLI \n''')
    file.write(''' \n''')
    file.write('''        opts = self.options \n''')
    file.write(''' \n''')
    file.write('''        if opts.cluster: \n''')
    file.write('''            servers = opts.cluster.split( ',' ) \n''')
    file.write('''            for server in servers: \n''')
    file.write('''                ClusterCleanup.add( server ) \n''')
    file.write(''' \n''')
    file.write('''        if opts.clean: \n''')
    file.write('''            cleanup() \n''')
    file.write('''            exit() \n''')
    file.write(''' \n''')
    file.write('''        start = time.time() \n''')
    file.write(''' \n''')
    file.write('''        topo = MyTopology() \n''')
    file.write('''        switch = customClass( SWITCHES, opts.switch ) \n''')
    file.write('''        host = customClass( HOSTS, opts.host ) \n''')
    file.write(
        f'''        controller = lambda name: RemoteController(name=name, ip='{node["controller"][0]}', port={node["controller"][1]})\n''')
    file.write('''        link = customClass( LINKS, opts.link )\n''')
    file.write('''        listenPort = None\n''')
    file.write('''        if self.validate:\n''')
    file.write('''            self.validate( opts )\n''')
    file.write(''' \n''')
    file.write('''        if not opts.nolistenport:\n''')
    file.write('''            listenPort = opts.listenport\n''')
    file.write('''\n''')
    file.write('''        Net = MininetWithControlNet if opts.innamespace else Mininet\n''')
    file.write('''\n''')
    file.write('''        # Wait for controllers to connect unless we're running null test\n''')
    file.write('''        if ( opts.test and opts.test != [ 'none' ] and\n''')
    file.write('''             isinstance( opts.wait, bool ) ):\n''')
    file.write('''            opts.wait = True\n''')
    file.write('''\n''')
    # file.write(f'''        intfName = '{node["out_intf"]}'\n''')
    # file.write('''        info('*** Checking', intfName, '\\n')\n''')
    # file.write('''        checkIntf(intfName)\n''')
    file.write(''' \n''')
    file.write('''        mn = Net( topo=topo, \n''')
    file.write('''                  switch=switch, host=host, controller=controller, link=link, \n''')
    file.write('''                  ipBase=opts.ipbase, inNamespace=opts.innamespace, \n''')
    file.write('''                  xterms=opts.xterms, autoSetMacs=opts.mac, \n''')
    file.write('''                  autoStaticArp=opts.arp, autoPinCpus=opts.pin, \n''')
    file.write('''                  waitConnected=opts.wait, \n''')
    file.write('''                  listenPort=listenPort ) \n''')
    file.write('''         \n''')
    # file.write('''        for sw in mn.switches: \n''')
    # file.write('''            if sw.name in sw_ext_intf: \n''')
    # file.write('''                info('*** Adding hardware interface', intfName, 'to switch', \n''')
    # file.write('''                     sw.name, '\\n') \n''')
    # file.write('''                _intf = Intf(intfName, node=sw) \n''')
    file.write('''        count = 1\n''')
    file.write('''        for s_from, s_to in sw_ext_intf_edges:\n''')
    file.write('''            S = name = None\n''')
    file.write('''            if s_from in (sw.name for sw in mn.switches):\n''')
    file.write('''                S = mn[s_from]\n''')
    file.write('''                name = s_from\n''')
    file.write('''            elif s_to in (sw.name for sw in mn.switches):\n''')
    file.write('''                S = mn[s_to]\n''')
    file.write('''                name = s_to\n''')
    file.write('''            if name == s_from:\n''')
    file.write('''                S.cmd(f"ip link add {name}-gre{count} type gretap local 12.12.12.{count} remote 14.14.14.{count} ttl 64")\n''')
    file.write('''                S.cmd(f"ip link set {name}-gre{count}" up)\n''')
    file.write('''                S.cmd(f"ip addr add dev {name}-gre{count}" 12.12.12.{count})\n''')
    file.write('''                Intf(f"{name}-gre{count}", node=S)\n''')
    file.write('''            elif name == s_to:\n''')
    file.write('''                S.cmd(f"ip link add {name}-gre{count} type gretap local 14.14.14.{count} remote 12.12.12.{count} ttl 64")\n''')
    file.write('''                S.cmd(f"ip link set {name}-gre{count}" up)\n''')
    file.write('''                S.cmd(f"ip addr add dev {name}-gre{count}" 14.14.14.{count})\n''')
    file.write('''                Intf(f"{name}-gre{count}", node=S)\n''')
    file.write('''            count += 1\n''')
    file.write(''' \n''')
    file.write('''        info('*** Note: you may need to reconfigure the interfaces for ' \n''')
    file.write('''             'the Mininet hosts:\\n', mn.hosts, '\\n') \n''')
    file.write(''' \n''')
    file.write('''        if opts.ensure_value( 'nat', False ): \n''')
    file.write('''            with open( '/etc/resolv.conf' ) as f: \n''')
    file.write('''                if 'nameserver 127.' in f.read(): \n''')
    file.write('''                    warn( '*** Warning: loopback address in /etc/resolv.conf ' \n''')
    file.write('''                          'may break host DNS over NAT\\n') \n''')
    file.write('''            mn.addNAT( *opts.nat_args, **opts.nat_kwargs ).configDefault() \n''')
    file.write(''' \n''')
    file.write('''        # --custom files can set CLI or change mininet.cli.CLI \n''')
    file.write('''        CLI = mininet.cli.CLI if CLI is None else CLI \n''')
    file.write(''' \n''')
    file.write('''        if opts.pre: \n''')
    file.write('''            CLI( mn, script=opts.pre ) \n''')
    file.write(''' \n''')
    file.write('''        mn.start() \n''')
    file.write(''' \n''')
    file.write('''        if opts.test: \n''')
    file.write('''            runTests( mn, opts.test ) \n''')
    file.write('''        else: \n''')
    file.write('''            CLI( mn ) \n''')
    file.write(''' \n''')
    file.write('''        if opts.post: \n''')
    file.write('''            CLI( mn, script=opts.post ) \n''')
    file.write(''' \n''')
    file.write('''        mn.stop() \n''')
    file.write(''' \n''')
    file.write('''        elapsed = float( time.time() - start ) \n''')
    file.write('''        info( 'completed in %0.3f seconds\\n' % elapsed ) \n''')
    file.write(''' \n''')
    file.write(''' \n''')
    file.write('''if __name__ == "__main__": \n''')
    file.write('''    try: \n''')
    file.write('''        MininetRunner() \n''')
    file.write('''    except KeyboardInterrupt: \n''')
    file.write('''        info( "\\n\\nKeyboard Interrupt. Shutting down and cleaning up...\\n\\n") \n''')
    file.write('''        cleanup() \n''')
    file.write('''    except Exception:  # pylint: disable=broad-except \n''')
    file.write('''        # Print exception \n''')
    file.write('''        type_, val_, trace_ = sys.exc_info() \n''')
    file.write('''        errorMsg = ( "-"*80 + "\\n" + \n''')
    file.write('''                     "Caught exception. Cleaning up...\\n\\n" + \n''')
    file.write('''                     "%s: %s\\n" % ( type_.__name__, val_ ) + \n''')
    file.write('''                     "-"*80 + "\\n" ) \n''')
    file.write('''        error( errorMsg ) \n''')
    file.write('''        # Print stack trace to debug log \n''')
    file.write('''        import traceback \n''')
    file.write('''        stackTrace = traceback.format_exc() \n''')
    file.write('''        debug( stackTrace + "\\n" ) \n''')
    file.write('''        cleanup()\n''')

# if __name__ == "__main__":
#     file = open("test_sc", "w")
#     nodes_ext_intf = "eth1"
#     node_group = [0, 3, 4]
#     edge_group = [(0, 3), (0, 4)]
#     ext_intf_list = [0, 1, 2]
#     leaves = [3, 4, 5, 6]
#     node_ctrl_map = ("10.211.55.2", "6633")
#     hosts_net_services = {
#         "0": {
#             "dhcp": False,
#             "WEB": False,
#             "VIDEO": False,
#             "FTP": False,
#             "P2P": False,
#             "SMTP": False,
#         },
#         "1": {
#             "dhcp": False,
#             "WEB": False,
#             "VIDEO": False,
#             "FTP": False,
#             "P2P": False,
#             "SMTP": False,
#         },
#         "2": {
#             "dhcp": False,
#             "WEB": False,
#             "VIDEO": False,
#             "FTP": False,
#             "P2P": False,
#             "SMTP": False,
#         },
#         "3": {
#             "dhcp": True,
#             "WEB": False,
#             "VIDEO": False,
#             "FTP": False,
#             "P2P": False,
#             "SMTP": False,
#         },
#         "4": {
#             "dhcp": False,
#             "WEB": False,
#             "VIDEO": False,
#             "FTP": False,
#             "P2P": False,
#             "SMTP": False,
#         },
#         "5": {
#             "dhcp": False,
#             "WEB": False,
#             "VIDEO": False,
#             "FTP": False,
#             "P2P": False,
#             "SMTP": False,
#         },
#         "6": {
#             "dhcp": False,
#             "WEB": False,
#             "VIDEO": False,
#             "FTP": False,
#             "P2P": False,
#             "SMTP": False,
#         },
#     }
#
#     gen_mn_ns_script_by_template(
#         file,
#         nodes_ext_intf,
#         node_group,
#         edge_group,
#         ext_intf_list,
#         leaves,
#         node_ctrl_map,
#         hosts_net_services,
#     )
